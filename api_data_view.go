/*
Aifs api

aifs api

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DataViewApiService DataViewApi service
type DataViewApiService service

type ApiCreateDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	createDataViewRequest *CreateDataViewRequest
}

func (r ApiCreateDataViewRequest) CreateDataViewRequest(createDataViewRequest CreateDataViewRequest) ApiCreateDataViewRequest {
	r.createDataViewRequest = &createDataViewRequest
	return r
}

func (r ApiCreateDataViewRequest) Execute() (*CreateDataViewSuccessResp, *http.Response, error) {
	return r.ApiService.CreateDataViewExecute(r)
}

/*
CreateDataView Create a data view

Create a data view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDataViewRequest
*/
func (a *DataViewApiService) CreateDataView(ctx context.Context) ApiCreateDataViewRequest {
	return ApiCreateDataViewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateDataViewSuccessResp
func (a *DataViewApiService) CreateDataViewExecute(r ApiCreateDataViewRequest) (*CreateDataViewSuccessResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateDataViewSuccessResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.CreateDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createDataViewRequest == nil {
		return localVarReturnValue, nil, reportError("createDataViewRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDataViewRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDataItemInDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
	dataViewItemIdList *[]string
}

// ids of raw data which are expected to be deleted
func (r ApiDeleteDataItemInDataViewRequest) DataViewItemIdList(dataViewItemIdList []string) ApiDeleteDataItemInDataViewRequest {
	r.dataViewItemIdList = &dataViewItemIdList
	return r
}

func (r ApiDeleteDataItemInDataViewRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDataItemInDataViewExecute(r)
}

/*
DeleteDataItemInDataView Delete data item in a data view

Delete data item in a data view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiDeleteDataItemInDataViewRequest
*/
func (a *DataViewApiService) DeleteDataItemInDataView(ctx context.Context, dataViewId string) ApiDeleteDataItemInDataViewRequest {
	return ApiDeleteDataItemInDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
func (a *DataViewApiService) DeleteDataItemInDataViewExecute(r ApiDeleteDataItemInDataViewRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.DeleteDataItemInDataView")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/data-items"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataViewItemIdList == nil {
		return nil, reportError("dataViewItemIdList is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "dataViewItemIdList", r.dataViewItemIdList, "csv")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
}

func (r ApiDeleteDataViewRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDataViewExecute(r)
}

/*
DeleteDataView Delete a data view

Delete a data view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiDeleteDataViewRequest
*/
func (a *DataViewApiService) DeleteDataView(ctx context.Context, dataViewId string) ApiDeleteDataViewRequest {
	return ApiDeleteDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
func (a *DataViewApiService) DeleteDataViewExecute(r ApiDeleteDataViewRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.DeleteDataView")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDivideDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
	divideRawDataDataViewRequestInner *[]DivideRawDataDataViewRequestInner
}

func (r ApiDivideDataViewRequest) DivideRawDataDataViewRequestInner(divideRawDataDataViewRequestInner []DivideRawDataDataViewRequestInner) ApiDivideDataViewRequest {
	r.divideRawDataDataViewRequestInner = &divideRawDataDataViewRequestInner
	return r
}

func (r ApiDivideDataViewRequest) Execute() ([]DivideRawDataDataViewResponseInner, *http.Response, error) {
	return r.ApiService.DivideDataViewExecute(r)
}

/*
DivideDataView Divide data view

Divide data view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiDivideDataViewRequest
*/
func (a *DataViewApiService) DivideDataView(ctx context.Context, dataViewId string) ApiDivideDataViewRequest {
	return ApiDivideDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
//  @return []DivideRawDataDataViewResponseInner
func (a *DataViewApiService) DivideDataViewExecute(r ApiDivideDataViewRequest) ([]DivideRawDataDataViewResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DivideRawDataDataViewResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.DivideDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/raw-data-divide"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.divideRawDataDataViewRequestInner == nil {
		return localVarReturnValue, nil, reportError("divideRawDataDataViewRequestInner is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.divideRawDataDataViewRequestInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFilterAnnotationsInDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
	filterAnnotationsInDataViewRequest *FilterAnnotationsInDataViewRequest
}

func (r ApiFilterAnnotationsInDataViewRequest) FilterAnnotationsInDataViewRequest(filterAnnotationsInDataViewRequest FilterAnnotationsInDataViewRequest) ApiFilterAnnotationsInDataViewRequest {
	r.filterAnnotationsInDataViewRequest = &filterAnnotationsInDataViewRequest
	return r
}

func (r ApiFilterAnnotationsInDataViewRequest) Execute() (*FilterAnnotationsInDataViewResponse, *http.Response, error) {
	return r.ApiService.FilterAnnotationsInDataViewExecute(r)
}

/*
FilterAnnotationsInDataView Filter annotations in a data view

Filter annotations in a data view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiFilterAnnotationsInDataViewRequest
*/
func (a *DataViewApiService) FilterAnnotationsInDataView(ctx context.Context, dataViewId string) ApiFilterAnnotationsInDataViewRequest {
	return ApiFilterAnnotationsInDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
//  @return FilterAnnotationsInDataViewResponse
func (a *DataViewApiService) FilterAnnotationsInDataViewExecute(r ApiFilterAnnotationsInDataViewRequest) (*FilterAnnotationsInDataViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilterAnnotationsInDataViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.FilterAnnotationsInDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/annotation-filter"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filterAnnotationsInDataViewRequest == nil {
		return localVarReturnValue, nil, reportError("filterAnnotationsInDataViewRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filterAnnotationsInDataViewRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllAnnotationDataInDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
}

func (r ApiGetAllAnnotationDataInDataViewRequest) Execute() (*AnnotationViewData, *http.Response, error) {
	return r.ApiService.GetAllAnnotationDataInDataViewExecute(r)
}

/*
GetAllAnnotationDataInDataView Get all annotation data in a data view

Get all annotation data in a data view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiGetAllAnnotationDataInDataViewRequest
*/
func (a *DataViewApiService) GetAllAnnotationDataInDataView(ctx context.Context, dataViewId string) ApiGetAllAnnotationDataInDataViewRequest {
	return ApiGetAllAnnotationDataInDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
//  @return AnnotationViewData
func (a *DataViewApiService) GetAllAnnotationDataInDataViewExecute(r ApiGetAllAnnotationDataInDataViewRequest) (*AnnotationViewData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnnotationViewData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.GetAllAnnotationDataInDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/annotation-data"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllAnnotationLocationsInDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
}

func (r ApiGetAllAnnotationLocationsInDataViewRequest) Execute() (*AnnotationViewLocations, *http.Response, error) {
	return r.ApiService.GetAllAnnotationLocationsInDataViewExecute(r)
}

/*
GetAllAnnotationLocationsInDataView Get all annotation locations in a data view

Get all annotation locations in a data view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiGetAllAnnotationLocationsInDataViewRequest
*/
func (a *DataViewApiService) GetAllAnnotationLocationsInDataView(ctx context.Context, dataViewId string) ApiGetAllAnnotationLocationsInDataViewRequest {
	return ApiGetAllAnnotationLocationsInDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
//  @return AnnotationViewLocations
func (a *DataViewApiService) GetAllAnnotationLocationsInDataViewExecute(r ApiGetAllAnnotationLocationsInDataViewRequest) (*AnnotationViewLocations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnnotationViewLocations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.GetAllAnnotationLocationsInDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/annotation-locations"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllRawDataLocationsInDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
}

func (r ApiGetAllRawDataLocationsInDataViewRequest) Execute() (*RawDataViewLocations, *http.Response, error) {
	return r.ApiService.GetAllRawDataLocationsInDataViewExecute(r)
}

/*
GetAllRawDataLocationsInDataView Get all raw data locations in a data view

Get all raw data locations in a data view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiGetAllRawDataLocationsInDataViewRequest
*/
func (a *DataViewApiService) GetAllRawDataLocationsInDataView(ctx context.Context, dataViewId string) ApiGetAllRawDataLocationsInDataViewRequest {
	return ApiGetAllRawDataLocationsInDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
//  @return RawDataViewLocations
func (a *DataViewApiService) GetAllRawDataLocationsInDataViewExecute(r ApiGetAllRawDataLocationsInDataViewRequest) (*RawDataViewLocations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RawDataViewLocations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.GetAllRawDataLocationsInDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/raw-data-locations"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAnnotationsInDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
	offset *int32
	limit *int32
	rawDataIdList *[]string
	labelId *string
}

// The number of items to skip before starting to collect the result set
func (r ApiGetAnnotationsInDataViewRequest) Offset(offset int32) ApiGetAnnotationsInDataViewRequest {
	r.offset = &offset
	return r
}

// The numbers of items to return
func (r ApiGetAnnotationsInDataViewRequest) Limit(limit int32) ApiGetAnnotationsInDataViewRequest {
	r.limit = &limit
	return r
}

// ids of raw data
func (r ApiGetAnnotationsInDataViewRequest) RawDataIdList(rawDataIdList []string) ApiGetAnnotationsInDataViewRequest {
	r.rawDataIdList = &rawDataIdList
	return r
}

func (r ApiGetAnnotationsInDataViewRequest) LabelId(labelId string) ApiGetAnnotationsInDataViewRequest {
	r.labelId = &labelId
	return r
}

func (r ApiGetAnnotationsInDataViewRequest) Execute() (*GetAnnotationsInDataView200Response, *http.Response, error) {
	return r.ApiService.GetAnnotationsInDataViewExecute(r)
}

/*
GetAnnotationsInDataView Get data view annotations

Get data view annotations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiGetAnnotationsInDataViewRequest
*/
func (a *DataViewApiService) GetAnnotationsInDataView(ctx context.Context, dataViewId string) ApiGetAnnotationsInDataViewRequest {
	return ApiGetAnnotationsInDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
//  @return GetAnnotationsInDataView200Response
func (a *DataViewApiService) GetAnnotationsInDataViewExecute(r ApiGetAnnotationsInDataViewRequest) (*GetAnnotationsInDataView200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAnnotationsInDataView200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.GetAnnotationsInDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.rawDataIdList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rawDataIdList", r.rawDataIdList, "csv")
	}
	if r.labelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labelId", r.labelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArtifactLocationsInDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
}

func (r ApiGetArtifactLocationsInDataViewRequest) Execute() (*ArtifactLocations, *http.Response, error) {
	return r.ApiService.GetArtifactLocationsInDataViewExecute(r)
}

/*
GetArtifactLocationsInDataView Get files' locations in artifact data view

Get files' locations in artifact data view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiGetArtifactLocationsInDataViewRequest
*/
func (a *DataViewApiService) GetArtifactLocationsInDataView(ctx context.Context, dataViewId string) ApiGetArtifactLocationsInDataViewRequest {
	return ApiGetArtifactLocationsInDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
//  @return ArtifactLocations
func (a *DataViewApiService) GetArtifactLocationsInDataViewExecute(r ApiGetArtifactLocationsInDataViewRequest) (*ArtifactLocations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArtifactLocations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.GetArtifactLocationsInDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/artifact-locations"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataViewDetailsRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
}

func (r ApiGetDataViewDetailsRequest) Execute() (*DataViewDetails, *http.Response, error) {
	return r.ApiService.GetDataViewDetailsExecute(r)
}

/*
GetDataViewDetails Get data view details

Get data view details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiGetDataViewDetailsRequest
*/
func (a *DataViewApiService) GetDataViewDetails(ctx context.Context, dataViewId string) ApiGetDataViewDetailsRequest {
	return ApiGetDataViewDetailsRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
//  @return DataViewDetails
func (a *DataViewApiService) GetDataViewDetailsExecute(r ApiGetDataViewDetailsRequest) (*DataViewDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataViewDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.GetDataViewDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataViewListRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	offset *int32
	limit *int32
	dataViewIdList *string
	dataViewName *string
}

// The number of items to skip before starting to collect the result set
func (r ApiGetDataViewListRequest) Offset(offset int32) ApiGetDataViewListRequest {
	r.offset = &offset
	return r
}

// The numbers of items to return
func (r ApiGetDataViewListRequest) Limit(limit int32) ApiGetDataViewListRequest {
	r.limit = &limit
	return r
}

// data view with id in data view id list will be got
func (r ApiGetDataViewListRequest) DataViewIdList(dataViewIdList string) ApiGetDataViewListRequest {
	r.dataViewIdList = &dataViewIdList
	return r
}

// data view name filter, support fuzzy query
func (r ApiGetDataViewListRequest) DataViewName(dataViewName string) ApiGetDataViewListRequest {
	r.dataViewName = &dataViewName
	return r
}

func (r ApiGetDataViewListRequest) Execute() ([]DataViewListItem, *http.Response, error) {
	return r.ApiService.GetDataViewListExecute(r)
}

/*
GetDataViewList Get data view list

Get data view list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDataViewListRequest
*/
func (a *DataViewApiService) GetDataViewList(ctx context.Context) ApiGetDataViewListRequest {
	return ApiGetDataViewListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DataViewListItem
func (a *DataViewApiService) GetDataViewListExecute(r ApiGetDataViewListRequest) ([]DataViewListItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DataViewListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.GetDataViewList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.dataViewIdList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataViewIdList", r.dataViewIdList, "")
	}
	if r.dataViewName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataViewName", r.dataViewName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataViewStatisticsRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
}

func (r ApiGetDataViewStatisticsRequest) Execute() (*DataViewStatistics, *http.Response, error) {
	return r.ApiService.GetDataViewStatisticsExecute(r)
}

/*
GetDataViewStatistics Get data view statistics

Get data view statistics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiGetDataViewStatisticsRequest
*/
func (a *DataViewApiService) GetDataViewStatistics(ctx context.Context, dataViewId string) ApiGetDataViewStatisticsRequest {
	return ApiGetDataViewStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
//  @return DataViewStatistics
func (a *DataViewApiService) GetDataViewStatisticsExecute(r ApiGetDataViewStatisticsRequest) (*DataViewStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataViewStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.GetDataViewStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatasetZipLocationInDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
}

func (r ApiGetDatasetZipLocationInDataViewRequest) Execute() (*DatasetZipLocation, *http.Response, error) {
	return r.ApiService.GetDatasetZipLocationInDataViewExecute(r)
}

/*
GetDatasetZipLocationInDataView Get dataset zip's location in a data view

Get dataset zip's location in a data view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiGetDatasetZipLocationInDataViewRequest
*/
func (a *DataViewApiService) GetDatasetZipLocationInDataView(ctx context.Context, dataViewId string) ApiGetDatasetZipLocationInDataViewRequest {
	return ApiGetDatasetZipLocationInDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
//  @return DatasetZipLocation
func (a *DataViewApiService) GetDatasetZipLocationInDataViewExecute(r ApiGetDatasetZipLocationInDataViewRequest) (*DatasetZipLocation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DatasetZipLocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.GetDatasetZipLocationInDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/dataset-zip-location"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetModelDataLocationsInDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
}

func (r ApiGetModelDataLocationsInDataViewRequest) Execute() (*ModelDataViewLocations, *http.Response, error) {
	return r.ApiService.GetModelDataLocationsInDataViewExecute(r)
}

/*
GetModelDataLocationsInDataView Get all model data locations in a data view

Get all model data locations in a data view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiGetModelDataLocationsInDataViewRequest
*/
func (a *DataViewApiService) GetModelDataLocationsInDataView(ctx context.Context, dataViewId string) ApiGetModelDataLocationsInDataViewRequest {
	return ApiGetModelDataLocationsInDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
//  @return ModelDataViewLocations
func (a *DataViewApiService) GetModelDataLocationsInDataViewExecute(r ApiGetModelDataLocationsInDataViewRequest) (*ModelDataViewLocations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelDataViewLocations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.GetModelDataLocationsInDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/model-data-locations"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawDataHashListInDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
	offset *int32
	limit *int32
}

// The number of items to skip before starting to collect the result set
func (r ApiGetRawDataHashListInDataViewRequest) Offset(offset int32) ApiGetRawDataHashListInDataViewRequest {
	r.offset = &offset
	return r
}

// The numbers of items to return
func (r ApiGetRawDataHashListInDataViewRequest) Limit(limit int32) ApiGetRawDataHashListInDataViewRequest {
	r.limit = &limit
	return r
}

func (r ApiGetRawDataHashListInDataViewRequest) Execute() ([]RawDataHashListInner, *http.Response, error) {
	return r.ApiService.GetRawDataHashListInDataViewExecute(r)
}

/*
GetRawDataHashListInDataView Get data view raw data hash list

Get data view raw data hash list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiGetRawDataHashListInDataViewRequest
*/
func (a *DataViewApiService) GetRawDataHashListInDataView(ctx context.Context, dataViewId string) ApiGetRawDataHashListInDataViewRequest {
	return ApiGetRawDataHashListInDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
//  @return []RawDataHashListInner
func (a *DataViewApiService) GetRawDataHashListInDataViewExecute(r ApiGetRawDataHashListInDataViewRequest) ([]RawDataHashListInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RawDataHashListInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.GetRawDataHashListInDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/raw-data-hash-list"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawDataInDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
	offset *int32
	limit *int32
	rawDataIdList *[]string
	excludedAnnotationViewId *string
	includedAnnotationViewId *string
}

// The number of items to skip before starting to collect the result set
func (r ApiGetRawDataInDataViewRequest) Offset(offset int32) ApiGetRawDataInDataViewRequest {
	r.offset = &offset
	return r
}

// The numbers of items to return
func (r ApiGetRawDataInDataViewRequest) Limit(limit int32) ApiGetRawDataInDataViewRequest {
	r.limit = &limit
	return r
}

// ids of raw data
func (r ApiGetRawDataInDataViewRequest) RawDataIdList(rawDataIdList []string) ApiGetRawDataInDataViewRequest {
	r.rawDataIdList = &rawDataIdList
	return r
}

// excluded annotation view with id. Return the raw data items which have no annotation in the annotation view.
func (r ApiGetRawDataInDataViewRequest) ExcludedAnnotationViewId(excludedAnnotationViewId string) ApiGetRawDataInDataViewRequest {
	r.excludedAnnotationViewId = &excludedAnnotationViewId
	return r
}

// included annotation view with id. Return the raw data items which have annotation in the annotation view.
func (r ApiGetRawDataInDataViewRequest) IncludedAnnotationViewId(includedAnnotationViewId string) ApiGetRawDataInDataViewRequest {
	r.includedAnnotationViewId = &includedAnnotationViewId
	return r
}

func (r ApiGetRawDataInDataViewRequest) Execute() (*GetRawDataInDataView200Response, *http.Response, error) {
	return r.ApiService.GetRawDataInDataViewExecute(r)
}

/*
GetRawDataInDataView Get data view raw data

Get data view raw data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiGetRawDataInDataViewRequest
*/
func (a *DataViewApiService) GetRawDataInDataView(ctx context.Context, dataViewId string) ApiGetRawDataInDataViewRequest {
	return ApiGetRawDataInDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
//  @return GetRawDataInDataView200Response
func (a *DataViewApiService) GetRawDataInDataViewExecute(r ApiGetRawDataInDataViewRequest) (*GetRawDataInDataView200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawDataInDataView200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.GetRawDataInDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/raw-data"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.rawDataIdList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rawDataIdList", r.rawDataIdList, "csv")
	}
	if r.excludedAnnotationViewId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludedAnnotationViewId", r.excludedAnnotationViewId, "")
	}
	if r.includedAnnotationViewId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includedAnnotationViewId", r.includedAnnotationViewId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHardDeleteDataViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
}

func (r ApiHardDeleteDataViewRequest) Execute() (*http.Response, error) {
	return r.ApiService.HardDeleteDataViewExecute(r)
}

/*
HardDeleteDataView Hard delete a data view

Hard delete a data view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiHardDeleteDataViewRequest
*/
func (a *DataViewApiService) HardDeleteDataView(ctx context.Context, dataViewId string) ApiHardDeleteDataViewRequest {
	return ApiHardDeleteDataViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
func (a *DataViewApiService) HardDeleteDataViewExecute(r ApiHardDeleteDataViewRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.HardDeleteDataView")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/hard-delete"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMergeDataViewsRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	mergeDataViewsRequest *MergeDataViewsRequest
}

func (r ApiMergeDataViewsRequest) MergeDataViewsRequest(mergeDataViewsRequest MergeDataViewsRequest) ApiMergeDataViewsRequest {
	r.mergeDataViewsRequest = &mergeDataViewsRequest
	return r
}

func (r ApiMergeDataViewsRequest) Execute() (*MergeDataViewsSuccessResp, *http.Response, error) {
	return r.ApiService.MergeDataViewsExecute(r)
}

/*
MergeDataViews Merge data views

Merge data views, generate a new data view to put the result

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMergeDataViewsRequest
*/
func (a *DataViewApiService) MergeDataViews(ctx context.Context) ApiMergeDataViewsRequest {
	return ApiMergeDataViewsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MergeDataViewsSuccessResp
func (a *DataViewApiService) MergeDataViewsExecute(r ApiMergeDataViewsRequest) (*MergeDataViewsSuccessResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MergeDataViewsSuccessResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.MergeDataViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/merge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mergeDataViewsRequest == nil {
		return localVarReturnValue, nil, reportError("mergeDataViewsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mergeDataViewsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMergeDataViewsToCrurrentRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
	mergeDataViewsRequest *MergeDataViewsRequest
}

func (r ApiMergeDataViewsToCrurrentRequest) MergeDataViewsRequest(mergeDataViewsRequest MergeDataViewsRequest) ApiMergeDataViewsToCrurrentRequest {
	r.mergeDataViewsRequest = &mergeDataViewsRequest
	return r
}

func (r ApiMergeDataViewsToCrurrentRequest) Execute() (*http.Response, error) {
	return r.ApiService.MergeDataViewsToCrurrentExecute(r)
}

/*
MergeDataViewsToCrurrent Merge data views

Merge other data views to current data view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiMergeDataViewsToCrurrentRequest
*/
func (a *DataViewApiService) MergeDataViewsToCrurrent(ctx context.Context, dataViewId string) ApiMergeDataViewsToCrurrentRequest {
	return ApiMergeDataViewsToCrurrentRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
func (a *DataViewApiService) MergeDataViewsToCrurrentExecute(r ApiMergeDataViewsToCrurrentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.MergeDataViewsToCrurrent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/merge"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mergeDataViewsRequest == nil {
		return nil, reportError("mergeDataViewsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mergeDataViewsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMoveDataViewItemsRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	moveDataViewItemsRequest *MoveDataViewItemsRequest
}

func (r ApiMoveDataViewItemsRequest) MoveDataViewItemsRequest(moveDataViewItemsRequest MoveDataViewItemsRequest) ApiMoveDataViewItemsRequest {
	r.moveDataViewItemsRequest = &moveDataViewItemsRequest
	return r
}

func (r ApiMoveDataViewItemsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MoveDataViewItemsExecute(r)
}

/*
MoveDataViewItems Move data items between data views

Move data items from data view A to data view B

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoveDataViewItemsRequest
*/
func (a *DataViewApiService) MoveDataViewItems(ctx context.Context) ApiMoveDataViewItemsRequest {
	return ApiMoveDataViewItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DataViewApiService) MoveDataViewItemsExecute(r ApiMoveDataViewItemsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.MoveDataViewItems")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/move"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveDataViewItemsRequest == nil {
		return nil, reportError("moveDataViewItemsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveDataViewItemsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateDatasetZipViewRequest struct {
	ctx context.Context
	ApiService *DataViewApiService
	dataViewId string
	updateDatasetZipRequest *UpdateDatasetZipRequest
}

// Update an existed dataset-zip view&#39;s meta
func (r ApiUpdateDatasetZipViewRequest) UpdateDatasetZipRequest(updateDatasetZipRequest UpdateDatasetZipRequest) ApiUpdateDatasetZipViewRequest {
	r.updateDatasetZipRequest = &updateDatasetZipRequest
	return r
}

func (r ApiUpdateDatasetZipViewRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateDatasetZipViewExecute(r)
}

/*
UpdateDatasetZipView Update a dataset-zip view meta

Update a dataset-zip view meta

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataViewId The id of a data view
 @return ApiUpdateDatasetZipViewRequest
*/
func (a *DataViewApiService) UpdateDatasetZipView(ctx context.Context, dataViewId string) ApiUpdateDatasetZipViewRequest {
	return ApiUpdateDatasetZipViewRequest{
		ApiService: a,
		ctx: ctx,
		dataViewId: dataViewId,
	}
}

// Execute executes the request
func (a *DataViewApiService) UpdateDatasetZipViewExecute(r ApiUpdateDatasetZipViewRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewApiService.UpdateDatasetZipView")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-views/{dataViewId}/dataset-zip"
	localVarPath = strings.Replace(localVarPath, "{"+"dataViewId"+"}", url.PathEscape(parameterValueToString(r.dataViewId, "dataViewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDatasetZipRequest == nil {
		return nil, reportError("updateDatasetZipRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDatasetZipRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
